#+TITLE: Introducción a Python
#+AUTHOR: Alejandro Gómez
#+EMAIL: alejandro@dialelo.com
#+OPTIONS: ':nil *:t -:t ::t <:t H:3 \n:nil ^:t arch:headline
#+OPTIONS: author:t c:nil creator:comment d:(not "LOGBOOK") date:t
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:t toc:nil todo:t |:t
#+DESCRIPTION:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: es
#+SELECT_TAGS: export

#+COMPANY: Kaleidos
#+WWW: http://dialelo.github.io
#+GITHUB: http://github.com/dialelo
#+TWITTER: dialelo

#+FAVICON: images/python-icon.png
#+ICON: images/python-logo.png

** ¿Qué es Python?

- [[https://www.python.org/- ][Python]] es un lenguaje de programación
 * interpretado
 * interactivo
 * dinámico
 * de propósito general
 * multi paradigma
 * que viene con pilas incluídas
- Creado por [[http://es.wikipedia.org/wiki/Guido_van_Rossum][Guido Van Rossum]] en 1991
- Nombrado en honor al grupo de humoristas [[http://es.wikipedia.org/wiki/Monty_Python][Monty Python]]

#+BEGIN_SRC python
print("¡Hola Python!")
#+END_SRC

** Interpretado e interactivo

- Python es un [[http://en.wikipedia.org/wiki/Interpreted_language][lenguaje interpretado]]
- El compilador de Python emite /bytecode/ que su máquina virtual interpreta
- Viene instalado en todos los UNIX modernos
- Podemos desarrollar de forma interactiva en el [[http://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop][REPL]]

#+BEGIN_SRC shell
python
# una vez en el intérprete, ejecutad `import this`
#+END_SRC

** Dinámico

- No es necesario declarar variables ni sus tipos
- Si queremos usar una variable, le asignamos un valor

#+BEGIN_SRC python
meaning_of_life = 42
print("What is the meaning of life, Universe and everything?")
#=> "What is the meaning of life, Universe and everything?"
print(meaning_of_life)
#=> 42
#+END_SRC

- Reasignar un valor a una variable existente la sobreescribe

#+BEGIN_SRC python
meaning_of_life = "MONEY DOLLAR$$$$$"
print(meaning_of_life)
#=> "MONEY DOLLAR$$$$$"
#+END_SRC

** De propósito general

- Es un lenguaje *simple* y *legible*
- Se utiliza en ámbitos muy variados
 * Computación científica
 * Programación de videojuegos
 * Desarrollo web
 * Aplicaciones de escritorio
 * Aplicaciones móviles
 * Microcontroladores
 * …

** Multi paradigma

- Programación procedural
- Orientación a objetos
 * En Python *todo* es un objeto
  + instancias
  + tipos
  + módulos
- Programación funcional

* Aquí hemos venido a jugar
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Preparándonos para el taller

1. Descargad el repositorio: https://github.com/dialelo/python_koans
2. Entrad en el directorio ~python3~
3. Ejecutad el script ~run.sh~, o ~run.bat~ si usáis Windows
4. Os dará un error, abrimos el fichero ~koans/about_asserts.py~
5. Comenzad vuestro camino a la iluminación

* Tipos de datos
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Booleanos

- ~True~ y ~False~
 * son objetos /singleton/
#+BEGIN_SRC python
True is True
#=> True
False is False
#=> True
True == True
#=> True
False == False
#=> True
True == False
#=> False
False == True
#=> False
#+END_SRC

** Booleanos

- Muchos objetos en Python pueden usarse en contextos en que se espera un booleano
#+BEGIN_SRC python
if 42:
    print("Life!")
#=> "Life!"

if not(0):
    print("0 is falsy")
#=> "0 is falsy"

if not(""):
    print("Empty string is falsy")
#=> "Empty string is falsy"
#+END_SRC

** Booleanos

- Las colecciones vacías en Python son tratadas como ~False~
#+BEGIN_SRC python
if not([]): print("Empty list")
#=> "Empty list"

if not(()): print("Empty tuple")
#=> "Empty tuple"

if not({}): print("Empty dict")
#=> "Empty dict"

if not(set()): print("Empty set")
#=> "Empty set"
#+END_SRC

** Booleanos

1. Abrid el fichero ~koans/about_true_and_false.py~
2. Comenzad vuestro camino a la iluminación

** Strings

- Se pueden delimitar con una comilla doble o simple a cada lado
#+BEGIN_SRC python
"Hello, world."
'Hello, world.'
#+END_SRC
- También puedes usar tres comillas
#+BEGIN_SRC python
"""Hello, world."""
'''Hello, world.'''
#+END_SRC
- Las strings /raw/ tienen distintas reglas de escapado de caracters
#+BEGIN_SRC python
r"Raw string"
#+END_SRC

** Strings

- La barra invertida en los strings sirve como caracter de escape
#+BEGIN_SRC python
"They said \"no\""
#+END_SRC
- También sirve para continuar un string en la línea siguiente
#+BEGIN_SRC python
"Hello, \
world."
#+END_SRC

** Strings

- Las triples comillas nos permiten tener strings multi línea
#+BEGIN_SRC python
"""
Beautiful is better than ugly.
Explicit is better than implicit.
"""
#+END_SRC
- Además necesitan menos escapado
#+BEGIN_SRC python
"""Hello, "world"."""
#+END_SRC

** Strings

- El operador ~+~ sirve para concatenar strings
#+BEGIN_SRC python
hello = "Hello"
world = "world"
print(hello + ", " + world + ".")
#=> "Hello, world."
#+END_SRC
- Podemos obtener la longitud de un string con la función ~len~
#+BEGIN_SRC python
hello = "Hello"
print(len(hello))
#=> 5
#+END_SRC

** Strings

1. Abrid el fichero ~koans/about_strings.py~
2. Comenzad vuestro camino a la iluminación

** None

- Representa la ausencia de valor
- También se le conoce como
 * ~null~ en Java o JavaScript
 * ~nil~ el Lisp o Ruby
- En Python no es un /valor/, es un objeto
- Como ~True~ y ~False~ es un /singleton/, sólo existe uno
#+BEGIN_SRC python
None is None
#=> True
#+END_SRC

** None

- Si intentamos acceder a un atributo, lanzará una excepción ~AttributeError~
#+BEGIN_SRC python
None.foo
#=>
#  Traceback (most recent call last):
#   File "<stdin>", line 1, in <module>
# AttributeError: 'NoneType' object has no attribute 'foo'
#+END_SRC
- Es distinto a cualquier valor salvo ~None~

** None

1. Abrid el fichero ~koans/about_none.py~
2. Comenzad vuestro camino a la iluminación

* Control de flujo
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** if/else

- Es muy parecido al ~if/else~ en cualquier otro lenguaje
#+BEGIN_SRC python
if True:
    print("True is True OMG")
else:
    print("Not gonna run")
#=> "True is True OMG"
#+END_SRC
- La rama ~else~ es opcional
#+BEGIN_SRC python
if False:
    print("Not gonna run")
#+END_SRC

** if/else

- Se pueden combinar varias condiciones secuenciales con ~elif~
#+BEGIN_SRC python
if False:
    print("Not gonna run")
elif False:
    print("Not gonna run either")
elif False:
    print("Neither do I")
else:
    print("Who needs a switch statement?")
#=> "Who needs a switch statement?"
#+END_SRC

** while

- Es muy parecido al ~while~ en cualquier otro lenguaje
#+BEGIN_SRC python
i = 0
while i != 42:
    print("Inside the while")
    i = 42

print("We're done")
#=> "Inside the while"
#=> "We're done"
#+END_SRC

** while

- Podemos salir del bucle con ~break~
#+BEGIN_SRC python
i = 0
while i != 42:
    print(i)
    if i == 1: break
    i = i + 1

print("We're done")
#=> 0
#=> 1
#=> "We're done"
#+END_SRC

** while

- Podemos obviar el resto del bucle con ~continue~
#+BEGIN_SRC python
i = 0
while i < 3:
    i = i + 1
    if i == 2: continue
    print(i)

print("We're done")
#=> 1
#=> 3
#=> "We're done"
#+END_SRC

** for

- Nos permite iterar directamente sobre los elementos de un iterable
#+BEGIN_SRC python
for food in ["pizza", "burguers", "omelette"]:
    print("I like " + food)
#=> "I like pizza"
#=> "I like burguers"
#=> "I like omelette"
#+END_SRC

** for

- La iteración no está limita a un elemento
#+BEGIN_SRC python
food_valorations = (
   ("pizza", "is good"),
   ("burguer", "is rad"),
   ("salad", "sucks")
)
for food, valoration in food_valorations:
    print(food + " " + valoration)
#=> "pizza is good"
#=> "burguer is rad"
#=> "salad sucks"
#+END_SRC

** Control de flujo

1. Abrid el fichero ~koans/about_control_statements.py~
2. Comenzad vuestro camino a la iluminación

* Colecciones
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Listas

- Las listas son uno de los tipos más usados de Python
- Se pueden construir con ~list~
#+BEGIN_SRC python
list()
#=> []
#+END_SRC
- También podemos representarlas con un literal entre corchetes
#+BEGIN_SRC python
["Hello", "Python", "lists"]
#+END_SRC

** Listas

- Podemos acceder a elementos por índice
#+BEGIN_SRC python
l = ["Hello", "Python", "lists"]
print(l[0])
#=> "Hello"
print(l[1])
#=> "Python"
#+END_SRC
- Soportan índices negativos
#+BEGIN_SRC python
l = ["Hello", "Python", "lists"]
print(l[-1])
#=> "lists"
print(l[-2])
#=> "Python"
#+END_SRC

** Listas

- Podemos seleccionar rangos
#+BEGIN_SRC python
l = ["Hello", "Python", "lists"]
print(l[0:])
#=> ["Hello", "Python", "lists"]
print(l[1:])
#=> ["Python", "lists"]
print(l[1:2])
#=> ["Python"]
#+END_SRC

** Listas

- Soportan inserción en posiciones arbitrarias
#+BEGIN_SRC python
l = ["Hello", "Python", "lists"]
l.insert(0, "Hey")
print(l)
#=> ["Hey", "Hello", "Python", "lists"]
#+END_SRC
- Y adiciones por el final
#+BEGIN_SRC python
l = ["Hello"]
l.append("Python")
print(l)
#=> ["Hello", "Python"]
#+END_SRC

** Listas

- Podemos extraer elementos del final
#+BEGIN_SRC python
l = ["Hello", "Python"]
print(l.pop())
#=> "Python"
print(l)
#=> ["Hello"]
#+END_SRC
- O de cualquier posición
#+BEGIN_SRC python
l = ["Hello", "there", "Python"]
print(l.pop(1))
#=> "there"
print(l)
#=> ["Hello", "Python"]
#+END_SRC

** Listas

1. Abrid el fichero ~koans/about_lists.py~
2. Comenzad vuestro camino a la iluminación

** Diccionarios

- Las listas son probablemente el tipo más usado de Python
- Se pueden construir con ~dict~
#+BEGIN_SRC python
dict()
#=> {}
#+END_SRC
- También podemos representarlos con un literal entre llaves, con pares clave-valor separados por coma
#+BEGIN_SRC python
{ "hello": "hola", "bye": "adiós" }
#+END_SRC

** Diccionarios

- Podemos acceder a elementos por clave
#+BEGIN_SRC python
d = { "hello": "hola", "bye": "adiós" }
print(l["hello"])
#=> "hola"
print(l["bye"])
#=> "adios"
#+END_SRC
- Podemos asignar valores a claves
#+BEGIN_SRC python
d = { "hello": "kaixo" }
d["bye"] = "agur"
print(l["bye"])
#=> "agur"
#+END_SRC

** Diccionarios

- Podemos obtener todas sus claves
#+BEGIN_SRC python
d = { "hello": "hola", "bye": "adiós" }
print(d.keys())
#=> ["hello", "bye"]
#+END_SRC
- Y valores
#+BEGIN_SRC python
d = { "hello": "hola", "bye": "adiós" }
print(d.values())
#=> ["hola", "adiós"]
#+END_SRC

** Diccionarios

- Podemos comprobar si contienen una clave con el operador ~in~
#+BEGIN_SRC python
d = { "hello": "hola", "bye": "adiós" }
print("hello" in d)
#=> True
print("see you later" in d)
#=> False
#+END_SRC
- Y obtener los pares clave-valor
#+BEGIN_SRC python
d = { "hello": "hola", "bye": "adiós" }
print(d.items())
#=> [("bye", "adiós"), ("hello", "hola")]
#+END_SRC

** Diccionarios

1. Abrid el fichero ~koans/about_dictionaries.py~
2. Comenzad vuestro camino a la iluminación

** Tuplas

- Son inmutables
- Se pueden construir con ~tuple~
#+BEGIN_SRC python
tuple()
#=>
#+END_SRC
- También podemos representarlas con un literal entre paréntesis
#+BEGIN_SRC python
("Hello", "Python", "tuples")
#+END_SRC

** Tuplas

- Para desambiguar las expresiones entre paréntesis de las tuplas de un elemento hemos de añadirles una coma al final
#+BEGIN_SRC python
print((1))
#=> 1
print((1,))
#=> (1,)
#+END_SRC

** Tuplas

1. Abrid el fichero ~koans/about_tuples.py~
2. Comenzad vuestro camino a la iluminación

** Conjuntos

- Se pueden construir con ~set~
#+BEGIN_SRC python
set()
#=> set()
#+END_SRC
- También podemos representarlas con una secuencia de valores entre llaves
#+BEGIN_SRC python
{"Hello", "Python", "sets"}
#+END_SRC

** Conjuntos

- Podemos comprobar si contienen un valor con el operador ~in~
#+BEGIN_SRC python
s = {1, 2, 3}
print(4 in s)
#=> False
print(1 in s)
#=> True
#+END_SRC

** Conjuntos

- Sobrecargan operadores para implementar operaciones sobre conjuntos
#+BEGIN_SRC python
scotsmen = {'MacLeod', 'Wallace', 'Willie'}
warriors = {'MacLeod', 'Wallace', 'Leonidas'}

# diferencia
scotsmen - warriors

# unión
scotsmen | warriors

# intersección
scotsmen & warriors

# diferencia simétrica
scotsmen ^ warriors
#+END_SRC

** Conjuntos

1. Abrid el fichero ~koans/about_sets.py~
2. Comenzad vuestro camino a la iluminación

* Funciones
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Funciones

- Se definen con ~def~
- Pueden recibir argumentos posicionales
#+BEGIN_SRC python
def add(x, y):
    return x + y
print(add(21, 21))
#=> 42
#+END_SRC
- Pueden recibir un número arbitrario de argumentos posicionales
#+BEGIN_SRC python
def count(*args):
    "Return a count of the number of arguments passed."
    return len(args)
print(count(0, 1, 2))
#=> 3
#+END_SRC

** Funciones

- Los parámetros pueden tener valores por defecto
#+BEGIN_SRC python
def greet(name="Python"):
    print("Hello, " + name ".")
greet()
#=> "Hello, Python."
greet("UMA")
#=> "Hello, UMA."
#+END_SRC

** Funciones

- Pueden recibir parámetros por nombre
 * al llamar a funciones con argumentos por nombre, el orden es irrelevante
#+BEGIN_SRC python
def greet(greeting="Hello", name="Python"):
    print(greeting + ", " + name ".")
greet()
#=> "Hello, Python."
greet(greeting="Hola")
#=> "Hola, Python."
greet(name="UMA", greeting="Hola")
#=> "Hola, UMA."
#+END_SRC

** Lambdas

- Funciones anónimas
- Sólo pueden contener una expresión
- ~return~ implícito
#+BEGIN_SRC python
inc = lambda x: x + 1
print(inc(10))
#=> 11
#+END_SRC

** Lambdas

1. Abrid el fichero ~koans/about_lambdas.py~
2. Comenzad vuestro camino a la iluminación

* Programación orientada a objetos
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

** Clases

- Se definen con ~class~
- Se instancian llamando a su nombre con paréntesis al final, como si llamáramos a una función
#+BEGIN_SRC python
class Cat:
    "Feline master race."

felix = Cat()
#+END_SRC

** Clases

- El método ~__init__~ se llama al instanciar una clase
- Se puede acceder a todos los atributos y métodos
 * por convención, los atributos y métodos privados se prefijan con ~_~
- Los métodos de una clase reciben la instancia sobre la que se ejecutan como primer argumento
#+BEGIN_SRC python
class Cat:
    def __init__(self, name):
        self._name = name

felix = Cat("Felix")
print(felix._name)
#=> "Felix"
#+END_SRC

** Clases

- Almacenan los atributos en un diccionario interno al que podemos acceder
#+BEGIN_SRC python
class Cat:
    def __init__(self, name):
        self._name = name

felix = Cat("Felix")
print(felix.__dict__)
#=> {'_name': 'Felix'}
#+END_SRC

** Clases: propiedades

- Podemos definir propiedas en las clases, similar a los /getters/ y /setters/ en Java
#+BEGIN_SRC python
class Cat:
    def __init__(self):
        self._name = None

    def set_name(self, name):
        print("Setting name")
        self._name = name

    def get_name(self):
        print("Getting name")
        return self._name

    name = property(get_name, set_name)
#+END_SRC

** Clases: propiedades

#+BEGIN_SRC python
felix = Cat("Felix")
print(felix.name)
#=> "Getting name"
#=> "Felix"

felix.name = "Felix 2"
#=> "Setting name"

print(felix.name)
#=> "Getting name"
#=> "Felix 2"
#+END_SRC

** Clases: propiedades

- Podemos usar decoradores para definir propiedades de forma más concisa
#+BEGIN_SRC python
class Cat:
    def __init__(self):
        self._name = None

    @property
    def name(self):
        print("Getting name")
        return self._name

    @name.setter
    def set_name(self, name):
        print("Setting name")
        self._name = name
#+END_SRC

** Clases

- Podemos definir métodos especiales para reproducir una instancia o convertirla a un string
#+BEGIN_SRC python
class Cat:
   def __init__(self, name):
        self._name = name
   def __repr__(self):
        return "<Cat named '" + self._name + "'>"
   def __str__(self):
       return self._name

felix = Cat("Felix")
print(felix)
#=> "Felix"
print(repr(felix))
#=> "<Cat named 'Felix'>"

#+END_SRC

** Clases

1. Abrid el fichero ~koans/about_classes.py~
2. Comenzad vuestro camino a la iluminación

* Iteradores, comprensiones y generadores
  :PROPERTIES:
  :SLIDE:    segue dark quote
  :ASIDE:    right bottom
  :ARTICLE:  flexbox vleft auto-fadein
  :END:

* Gracias ˊ~ω~ˋ

:PROPERTIES:
:SLIDE: thank-you-slide segue
:ASIDE: right
:ARTICLE: flexbox vleft auto-fadein
:END:
